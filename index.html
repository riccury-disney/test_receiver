<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <style>
      body {
        margin: 0;
        background-color: black;
        font-size: 14pt;
      }

      p {
        color: #ffffff;
      }

      #player-wrapper {
        height: 100%;
        width: 100%;
        position: fixed;
      }

      #app-status-overlay {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        background-color: black;
        display: table;
      }

      #app-status-overlay-loading {
        display: table-cell;
        text-align: center;
        vertical-align: middle;
      }

      @keyframes app-status-overlay-loading-dot {
        0% {
          opacity: 1;
        }
        25% {
          opacity: 0;
        }
        50% {
          opacity: 0;
        }
        75% {
          opacity: 1;
        }
        100% {
          opacity: 1;
        }
      }

      .app-status-overlay-loading-dot {
        display: inline-block;
        width: 2em;
        height: 2em;
        border-radius: 50%;
        background-color: #777;
        margin: 0.3em;
        animation: app-status-overlay-loading-dot 4s ease-in infinite;
      }

      .app-status-overlay-loading-dot:nth-child(1) {
        animation-delay: 0.25s;
      }

      .app-status-overlay-loading-dot:nth-child(2) {
        animation-delay: 0.5s;
      }

      .app-status-overlay-loading-dot:nth-child(3) {
        animation-delay: 0.75s;
      }

      #watermark {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
      }

      .hidden {
        display: none;
      }

      .watermark-userid--center {
        font-size: 2.5vw;
        opacity: 0.3;
        font-weight: 300;
      }
    </style>
  </head>
  <body>
    <div id="player-wrapper"></div>
    <div id="watermark"></div>
    <div id="app-status-overlay">
      <div id="app-status-overlay-loading">
        <div class="app-status-overlay-loading-dot"></div>
        <div class="app-status-overlay-loading-dot"></div>
        <div class="app-status-overlay-loading-dot"></div>
      </div>
    </div>

    <link
      rel="stylesheet"
      href="https://cdn.bitmovin.com/player/web/8/bitmovinplayer-ui.css"
    />
    <script
      type="text/javascript"
      src="https://cdn.bitmovin.com/player/web/8/bitmovinplayer-ui.js"
    ></script>
    <script
      type="text/javascript"
      src="https://cdn.bitmovin.com/player/web/8/bitmovinplayer.js"
    ></script>
    <script
      type="text/javascript"
      src="//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js"
    ></script>
    <script
      type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.js"
      integrity="sha256-uvyqD81XGEqlTzEGkl+5L73IUlWTXtdLhfnUG5n3FbE="
      crossorigin="anonymous"
    ></script>
    <script
      type="text/javascript"
      src="https://cdn.bitmovin.com/player/cast/8.14.1-2/bitmovinplayer-remotereceiver.js"
    ></script>
    <script type="text/javascript">
      // Hide app loading overlay
      const hideStatusOverlay = () => {
        document.getElementById("app-status-overlay").style.display = "none";
      };

      window.onload = () => {
        let meta;

        // Bitmovin Player configuration properties
        const conf = {
          key: "79727bd9-f542-46a6-b585-dffd44b18dcf",
          tweaks: {
            fairplay_ignore_duplicate_init_data_key_errors: true,
            native_hls_parsing: true,
          },
          logs: {
            bitmovin: false, // turn off Bitmovin' credits in console
          },
          licensing: {
            delay: 10000, // delay license request by 10 seconds
          },
          analytics: {
            config: {
              enabled: false,
              cookiesEnabled: false,
            },
          },
          ui: false,
        };

        // Instantiate a Bitmovin player
        const player = new bitmovin.player.Player(
          document.getElementById("player-wrapper"),
          conf
        );

        // Hide loading overlay when a source is loaded
        player.on(bitmovin.player.PlayerEvent.SourceLoaded, hideStatusOverlay);

        // Hide overlay when an error happens (avoids hidden errors during startup)
        player.on(bitmovin.player.PlayerEvent.Error, hideStatusOverlay);

        // Update time
        // player.on(bitmovin.player.PlayerEvent.TimeChanged, () => {
        //   console.log("Time Changed:", player.getCurrentTime());
        // });

        const WATERMARK_TYPES = {
          userid: {
            centered: "userid-centered",
            temporary: "userid-centered-temporary",
          },
        };

        // useEffect(() => {
        //   if (
        //     isLogo.rotatingTemporary ||
        //     isLogo.stationaryTemporary ||
        //     isUserIdCorner.rotatingTemporary ||
        //     isUserIdCorner.stationaryTemporary ||
        //     isUserId.temporary
        //   ) {
        //     const runtimeInSeconds = Math.floor(playData.runtime * 60);
        //     const currentTime = Math.floor(meta.currentTime);

        //     // toggle first watermark 5% into the movie and second at 60%
        //     if (
        //       currentTime === runtimeInSeconds * 0.05 ||
        //       currentTime === runtimeInSeconds * 0.6
        //     ) {
        //       setIsVisible(true);
        //     }
        //   }
        // }, [meta.currentTime]);

        const handleVisibility = (runtime, el) => {
          player.on(bitmovin.player.PlayerEvent.TimeChanged, () => {
            const runtimeInSeconds = Math.floor(runtime * 60);
            const currentTime = Math.floor(player.getCurrentTime());
            el.classList.add("hidden");
            console.log("current time:", currentTime);
            console.log("runtime:", runtimeInSeconds);
            if (
              currentTime ===
              (runtimeInSeconds * 0.05 || runtimeInSeconds * 0.6)
            ) {
              el.classList.remove("hidden");
            }
          });
        };

        const watermarkUserIdCentered = (
          { text, runtime },
          { isTemporary = false } = {}
        ) => {
          const el = document.getElementById("watermark");
          const p = document.createElement("p");
          p.classList.add("watermark-userid--center");
          p.textContent = text;

          if (el) {
            el.append(p);
            console.log("temp", isTemporary);
            isTemporary && handleVisibility(runtime, p);
          }
        };

        const getWatermark = ({ entitlement, data }) => {
          console.log(entitlement);
          if (!entitlement) {
            return null;
          }

          switch (entitlement.watermarkType) {
            case WATERMARK_TYPES.userid.centered:
              watermarkUserIdCentered(
                { text: entitlement.watermarkText, runtime: data.runtime },
                {
                  isTemporary: true,
                }
              );
              break;
            case WATERMARK_TYPES.userid.temporary:
              break;
            default:
              break;
          }
        };

        require(["remotecontrol/GoogleCastRemoteControlReceiver"], (gcr) => {
          const googleCastRemoteControlReceiver = new gcr.GoogleCastRemoteControlReceiver(
            player
          );

          // Handler that takes properties from the remotecontrol.customReceiverConfig configuration for use within the receiver
          googleCastRemoteControlReceiver.setCastMetadataListener(
            (metadata) => {
              console.log("gcr metadata:", metadata);
              // switch (metadata.type) {
              //   case "customReceiverConfig":
              //     const customReceiverConfig = metadata.data;
              //     if (customReceiverConfig.receiverStylesheetUrl != null) {
              //       const head = document.getElementsByTagName("head")[0];
              //       const link = document.createElement("link");
              //       link.rel = "stylesheet";
              //       link.type = "text/css";
              //       link.href = customReceiverConfig.receiverStylesheetUrl;
              //       head.appendChild(link);
              //     }
              //     break;
              // }
              getWatermark({
                entitlement: metadata.entitlement,
                data: metadata.playData,
              });
            }
          );
        });

        // Load the built-in Bitmovin Cast Receiver UI
        const uimanager = bitmovin.playerui.UIFactory.buildDefaultCastReceiverUI(
          player
        );
      };
    </script>
  </body>
</html>
